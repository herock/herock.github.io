{"pages":[{"title":"","text":"google-site-verification: google9de04b5718a6898d.html","link":"/google9de04b5718a6898d.html"},{"title":"关于","text":"关于我。","link":"/about/index.html"}],"posts":[{"title":"试用 Dify 知识库后总结的几个要点","text":"今天稍微深入的试用了 Dify 知识库，记录一些要点： 一、API集成与功能入口Dify知识库提供便捷的API接口（位于知识库首页左上角导航栏右侧），支持开发者通过自定义工具提交数据，并轻松整合至现有系统架构中。 二、分段策略配置要点 Q&amp;A模式特性 该模式需在知识库创建时预先选择，后期不可变更 虽存在灵活性限制（无法按文档差异化设置），但实际生成效果显著，特别适用于FAQ类知识整理 建议：前期规划时明确内容类型，批量处理同类文档 参数调优指南 参数项 推荐范围 影响分析 调整策略 分段最大长度 200-600 过长引入噪音/过少丢失上下文 依据内容密度动态调整 分段重叠长度 50-150 不足导致语义断裂/冗余 保持10%-20%内容重叠 三、效果验证与召回测试 文档处理完成后，务必通过”召回测试”功能验证： 在”源文本”输入真实用户可能提问的自然语言 观察返回结果的关联性与完整性 典型案例测试建议覆盖高频查询场景 迭代优化流程测试效果不佳时，按以下顺序调整：1调整分段参数 → 优化检索参数 → 改进知识内容质量 四、高级检索参数解析 TopK动态调整机制 定义：返回最相关的前K个文档块（默认K=3） 系统根据模型上下文窗口自动优化片段数量 调参原则：资源充足时适当提高数值增强召回率 Score阈值控制 基于余弦相似度的过滤机制（默认阈值0.5） 数值与召回精度呈正相关，与数量呈负相关 推荐策略：初期设为默认值，逐步提升至质量瓶颈 参考文档： Dify官方知识库文档 DeepSeek与Dify集成开发指南","link":"/p/1053145340/"},{"title":"配置 AI Studio 访问的域名规则","text":"为了能够顺利访问 Google AI Studio (aistudio.google.com) 以及其相关服务，通常需要配置特定的域名代理规则。这些规则帮助确保网络请求被正确路由，从而绕过可能的访问限制。 以下是一份收集整理的推荐配置规则，适用于常见的代理工具（如 Clash, Surge, Quantumult X 等）所支持的域名规则格式。(没有逐一排查，可能有个别规则是非必需的) 域名规则列表1234567891011121314151617name: &apos;AI Studio&apos;desc: &apos;Google AI Studio&apos;rules: - DOMAIN,aistudio.google.com,proxy - DOMAIN,ai.google.dev,proxy - DOMAIN,ai.dev,proxy - DOMAIN-SUFFIX,makersuite.google.com,proxy - DOMAIN,alkalicore-pa.clients6.google.com,proxy - DOMAIN,alkalimakersuite-pa.clients6.google.com,proxy - DOMAIN-SUFFIX,generativeai.google,proxy - DOMAIN,developerprofiles-pa.googleapis.com,proxy - DOMAIN,content-developerprofiles-pa.googleapis.com,proxy - DOMAIN,fonts.googleapis.com,proxy - DOMAIN,www.google-analytics.com,proxy - DOMAIN,play.google.com,proxy - DOMAIN,people-pa.clients6.google.com,proxy - DOMAIN,waa-pa.clients6.google.com,proxy 在 Stash 中配置在 Stash 中，你可以通过以下步骤添加这些域名规则： 把上面的代码存成一个文件，如 aistudio.stoverride，并上传到可访问的服务器上，复制该文件的 url； 打开 Stash 的“控制面板”； 点“覆写” 点“从 URL 安装”，粘贴刚刚复制的 URL； 确保“覆写”和刚才添加的覆写规则的开关都打开。","link":"/p/3847286674/"},{"title":"Python-docx","text":"需要在 Dify 工作流里处理 word 文档，需要一个好用的能够处理 word 文档的库，问了下 Grok，最终决定用 python-docx 这个库，Grok 的研究报告在这里。","link":"/p/649363453/"},{"title":"自定义 Twitter 链接预览：Twitter Cards 详解","text":"当我们在 Twitter 上分享一个 URL 时，Twitter 会尝试抓取这个 URL 的信息，并以一种特定的卡片形式展示出来，这就是 Twitter Card。正确配置 Twitter Cards 可以显著改善链接在 Twitter 上的展示效果，并可能提高用户互动。 本文将介绍 Twitter Cards 的基本概念、主要类型、实现方式以及一些注意事项。 什么是 Twitter Cards？Twitter Cards 是一种通过在网页 HTML 的 &lt;head&gt; 部分添加特定 meta 标签来实现的富媒体展示功能。当有人分享你的网页链接到 Twitter 时，Twitter 的爬虫会读取这些 meta 标签，并根据其内容生成一个包含标题、描述、图片甚至视频播放器的卡片。 为什么使用 Twitter Cards？ 控制展示内容：你可以精确控制分享链接时显示的标题、描述和图片，而不是让 Twitter 自动抓取。 提升视觉吸引力：相比纯文本链接，带有图片或视频的卡片更吸引眼球。 提高点击率 (CTR)：更丰富和相关的预览信息通常能带来更高的点击率。 品牌一致性：确保分享内容符合你的品牌形象。 Twitter Cards 的类型Twitter 提供了几种不同类型的 Card，以适应不同的内容需求： Summary Card (摘要卡片) 用途：通用型卡片，适用于博客文章、新闻、产品页面等。 特点：包含标题、描述、缩略图以及 Twitter 账户归属。 关键 meta 标签：twitter:card 值为 summary。 Summary Card with Large Image (带大图的摘要卡片) 用途：与 Summary Card 类似，但图片展示区域更大，更突出。 特点：图片是卡片的主要视觉元素。 关键 meta 标签：twitter:card 值为 summary_large_image。 App Card (应用卡片) 用途：推广移动应用。 特点：直接显示应用名称、图标、评分、价格，并提供直接下载链接（指向应用商店）。 关键 meta 标签：twitter:card 值为 app。 Player Card (播放器卡片) 用途：分享音频或视频内容。 特点：允许用户直接在 Twitter 信息流中播放媒体内容。 关键 meta 标签：twitter:card 值为 player。需要提供视频/音频播放器 URL。 如何实现 Twitter Cards？实现 Twitter Cards 的核心是在你网页的 &lt;head&gt; 部分添加一系列 meta 标签。 以下是一个 summary_large_image 类型的基本示例： 123456789&lt;head&gt; &lt;meta name=\\&quot;twitter:card\\&quot; content=\\&quot;summary_large_image\\&quot;&gt; &lt;meta name=\\&quot;twitter:site\\&quot; content=\\&quot;@你的Twitter用户名\\&quot;&gt; &lt;meta name=\\&quot;twitter:creator\\&quot; content=\\&quot;@内容创作者的Twitter用户名\\&quot;&gt; &lt;meta name=\\&quot;twitter:title\\&quot; content=\\&quot;页面标题 - 最多70个字符\\&quot;&gt; &lt;meta name=\\&quot;twitter:description\\&quot; content=\\&quot;页面描述 - 最多200个字符\\&quot;&gt; &lt;meta name=\\&quot;twitter:image\\&quot; content=\\&quot;https://example.com/path/to/your/image.jpg\\&quot;&gt; &lt;meta name=\\&quot;twitter:image:alt\\&quot; content=\\&quot;图片的描述文字\\&quot;&gt;&lt;/head&gt; 关键 Meta 标签详解虽然不同类型的 Card 有其特定的标签，但以下是一些通用的和核心的标签： twitter:card: 定义 Card 的类型。这是必需的。 可选值: summary, summary_large_image, app, player。 twitter:site: 网站或公司的 Twitter 用户名，例如 @mytwitterhandle。通常是发布者的用户名。 twitter:creator: 内容创作者的 Twitter 用户名，例如 @authorhandle。可选，适用于多作者网站。 twitter:title: Card 的标题。对于 summary 类型，建议最多 70 个字符。 twitter:description: Card 的描述。对于 summary 类型，建议最多 200 个字符。如果描述为空，Twitter 可能会从页面内容中提取。 twitter:image: Card 中显示的图片的 URL。图片必须小于 5MB。 对于 summary 卡片，图片宽高比应为 1:1，最小尺寸 144x144px，最大尺寸 4096x4096px。 对于 summary_large_image 卡片，图片宽高比应为 2:1，最小尺寸 300x157px，最大尺寸 4096x4096px。 twitter:image:alt: 图片的描述性文本，用于可访问性 (Accessibility)。 twitter:player (Player Card 特有): 指向你的播放器 iframe 的 HTTPS URL。 twitter:player:width, twitter:player:height (Player Card 特有): 播放器的尺寸。 twitter:app:name:iphone, twitter:app:id:iphone, twitter:app:url:iphone (App Card 特有): 针对 iPhone 的应用信息。类似地，还有 ipad 和 googleplay 的对应标签。 调试和验证实现 Twitter Cards 后，务必使用 Twitter 官方提供的 Card Validator (卡片验证器) 进行测试。 地址：https://cards-dev.twitter.com/validator 通过验证器，你可以： 输入你的页面 URL。 预览 Card 在 Twitter 上的显示效果。 查看 Twitter 爬虫抓取到的 meta 标签信息以及任何错误或警告。 首次分享一个 URL 时，如果 Twitter 之前没有缓存过该页面的 Card 数据，可能需要几秒钟到几分钟来抓取和生成 Card。验证器可以帮助预先抓取和缓存。 ⚠️ 废弃提示：这个验证器现在已经被废弃，官方推荐直接在发帖窗口中预览 Card，无需额外操作。 注意事项 图片尺寸和格式：严格遵守 Twitter 对图片尺寸、宽高比和文件大小的规定，否则图片可能无法正确显示或被裁剪。支持 JPG, PNG, WEBP, GIF (GIF 只会显示第一帧作为静态图)。 URL 必须是绝对路径：所有 URL (如 twitter:image, twitter:player) 都应该是绝对路径，并正确编码。 HTTPS：对于 twitter:player 和 twitter:image 等资源，强烈建议使用 HTTPS 链接，以避免混合内容警告。Player Card 的 twitter:player URL 必须 是 HTTPS。 robots.txt：确保你的 robots.txt 文件没有禁止 Twitter 的爬虫 (Twitterbot) 访问你的页面和相关资源（如图片）。 缓存：Twitter 会缓存 Card 数据。如果你更新了页面的 meta 标签，可能需要一段时间才能在 Twitter 上看到更新。使用 Card Validator 可以帮助刷新缓存。 内容唯一性：每个页面应该有其自己独特的 Card 信息，以准确反映页面内容。 Open Graph (OG) 标签兼容性：如果页面上同时存在 Open Graph (OG) 标签 (如 og:title, og:image) 而没有相应的 Twitter Card 标签，Twitter 会尝试使用 OG 标签来生成 Card。但为了获得最佳控制，建议明确设置 Twitter Card 标签。如果两者都存在，Twitter Card 标签优先。 总结Twitter Cards 是一个简单但有效的工具，可以优化你的内容在 Twitter 上的传播效果。通过添加几个 meta 标签，就能让分享的链接更具吸引力，从而可能带来更高的用户参与度。花点时间正确配置它们是值得的。","link":"/p/390731927/"},{"title":"Cloudflare Workers 入门与实践","text":"这篇笔记记录一下 Cloudflare Workers 的基本概念、开发流程、本地测试以及部署方法。 一、什么是 Cloudflare Workers？Cloudflare Workers 允许你在 Cloudflare 的全球网络边缘运行 JavaScript、Rust、C 和 C++ 代码。这意味着你的代码可以非常靠近你的用户，从而减少延迟。 二、准备工作 Cloudflare 账户：你需要一个 Cloudflare 账户。 Node.js 和 npm：确保你安装了 Node.js (通常会附带 npm)。 Wrangler CLI：Cloudflare Workers 的官方命令行工具。123npm install -g wrangler# 或者使用 yarn# yarn global add wrangler登录 Wrangler:1wrangler login 三、创建和开发 Worker 创建项目:使用 Wrangler CLI 创建一个新的 Worker 项目：12wrangler init my-workercd my-worker这将生成一个包含基本结构的项目。 编写代码 (src/index.js 或 src/index.ts):一个简单的 “Hello World” Worker 可能如下所示：123456// src/index.jsexport default { async fetch(request, env, ctx) { return new Response(&apos;Hello World!&apos;); },}; 本地测试:使用 Wrangler CLI 在本地运行和测试你的 Worker：1wrangler dev这通常会在 http://localhost:8787 启动一个本地服务器。 对于更复杂的调试，可以在浏览器中访问本地 Worker 时使用浏览器的开发者工具 (Network, Console)。 四、部署 Worker 部署到 .workers.dev 子域名:1wrangler deploy首次部署时，Wrangler 可能会提示你一些信息。成功后，你的 Worker 会部署到一个 your-worker-name.your-subdomain.workers.dev 的 URL。 部署到自定义域名:如果你想将 Worker 部署到你自己的域名 (例如 api.example.com)，你需要在 Cloudflare Dashboard 中配置相应的 DNS 记录和路由。 然后再次运行 wrangler deploy。请查阅最新的 Cloudflare Workers 文档以获取准确的配置方法。 五、总结Cloudflare Workers 提供了一种强大且高效的方式来构建和部署无服务器应用程序。通过 Wrangler CLI，开发、测试和部署流程都变得相对简单。","link":"/p/250510225115/"},{"title":"一次没有成功的将 MacBook 内容投屏到特斯拉上的尝试","text":"今天在车里等人，用电脑工作时在想能不能把特斯拉的屏幕变成扩展屏，以前一直懒得研究，但今天决定花点时间弄明白到底行不行，于是和 Gemini 聊了起来，以下是研究结束后我让它帮我生成的文章： 起初的设想：理想中的“扩展屏幕”我最初的设想很简单：能不能像连接普通外接显示器一样，将特斯拉屏幕作为MacBook的扩展副屏？这样我就可以在MacBook上处理主要任务，同时在特斯拉屏幕上查阅资料、展示内容，实现高效的多任务处理。 然而，现实很快给了我一盆冷水： 特斯拉没有视频输入接口：它不像显示器那样提供HDMI或USB-C视频输入。 缺乏原生扩展协议支持：特斯拉系统也不支持如苹果AirPlay Display接收或Miracast这类无线扩展屏幕的协议。 看来，直接的“扩展屏幕”方案是行不通了。 转变思路：曲线救国，利用特斯拉浏览器既然无法直接扩展，我想到特斯拉强大的车载浏览器。如果能将MacBook的屏幕内容通过某种方式“流式传输”到浏览器上显示，不也能达到类似的效果吗？ 方案一：第三方投屏软件我调研了一些支持将电脑屏幕投射到浏览器的第三方软件，例如 LetsView。这类软件通常的工作原理是： 在MacBook上运行投屏软件服务端。 软件生成一个局域网内的HTTP地址。 在同一局域网下的设备浏览器中打开这个地址，即可看到MacBook的屏幕镜像。 这种方式理论上可行，并且我还希望实现更精细的控制：在MacBook上进行编程，同时在特斯拉屏幕上显示参考文档。 这又引申出两种操作思路： 投射特定窗口：LetsView等软件通常允许选择投射整个屏幕或某个特定的应用程序窗口。我可以将文档窗口（如Preview或浏览器）投射出去。 使用虚拟显示器：通过像BetterDisplay这样的软件，在Mac上创建一个虚拟显示器，将文档窗口拖到这个虚拟屏上，然后用LetsView专门投射这个虚拟显示器的内容。这样MacBook主屏可以完全用于编程。 理论上，这两种方式都能满足我的需求，只是后者设置更复杂，但体验可能更接近“双屏”。 关键的测试环节：搭建本地Web服务为了验证局域网内的浏览器访问能力，我决定先从最简单的做起：在MacBook上搭建一个本地Web服务，看看特斯拉浏览器能否访问。 我使用了Python内置的HTTP服务模块，在MacBook上执行了以下命令，并在特定目录下放置了一个简单的index.html文件： 1python3 -m http.server 8787 此时，我的网络环境是： MacBook 通过Wi-Fi连接到我的iPhone个人热点。 特斯拉也连接到同一个iPhone个人热点。 MacBook在iPhone热点下获取到的IP地址是 172.20.10.13。 遭遇瓶颈：无法跨越的“鸿沟”一切准备就绪后，我开始测试： MacBook本机访问：在MacBook的浏览器中输入 http://localhost:8787 或 http://172.20.10.13:8787，均能成功访问到我的index.html页面。这证明Web服务本身是正常的。 iPhone（热点提供者）访问：令人惊喜的是，在开启热点的这部iPhone上，通过Safari浏览器访问 http://172.20.10.13:8787，竟然也成功了！ 这让我一度以为胜利在望。 特斯拉浏览器访问：然而，当我在特斯拉的浏览器中满怀期待地输入 http://172.20.10.13:8787 时，却始终无法连接，页面加载失败。 我检查了Mac的防火墙，确认已允许Python程序或8787端口的传入连接。Web服务也确认监听在 0.0.0.0，意味着接受所有网络接口的连接。 最终的结论：iPhone热点的“客户端隔离”为什么iPhone本身能访问Mac的服务，而同处于一个热点下的特斯拉却不能？ 经过一番查阅和思考，答案指向了iPhone个人热点的一个特性：客户端隔离 (AP Isolation / Client Isolation)。 什么是客户端隔离？ 很多Wi-Fi热点（尤其是手机热点）为了安全起见，会默认启用客户端隔离。这意味着，连接到该热点的各个客户端设备之间是相互隔离的，它们可以访问互联网，但不能直接互相通信或发现对方提供的服务。iPhone作为热点的提供者，它本身与直接连接的设备（MacBook）之间可能存在特殊的通信权限，所以它可以访问MacBook的服务。 但特斯拉作为另一个独立的客户端，就被这个隔离策略挡在了门外。 这也就解释了： 我的MacBook Web服务是正常的。 我的MacBook防火墙设置是正确的。 问题出在iPhone热点对客户端之间通信的限制上。 总结与后续方案这次探索虽然没有完全达到最初“扩展屏幕”的理想状态，但也让我彻底弄清了在iPhone热点环境下进行此类操作的限制。 核心结论： 将MacBook屏幕内容投射到特斯拉浏览器是可行的，可以使用LetsView等第三方软件，并选择投射特定窗口或配合虚拟显示器实现。 iPhone个人热点的客户端隔离是主要障碍：如果你依赖iPhone热点组网，那么MacBook和特斯拉之间的直接局域网通信（如访问Mac上自建的Web服务或接收投屏流）会失败。 解决方案是更换网络环境：要实现稳定的投屏，MacBook和特斯拉需要连接到一个不启用客户端隔离的Wi-Fi网络，例如： 家庭或办公室的Wi-Fi路由器（通常可以配置或默认不隔离）。 支持关闭客户端隔离功能的便携式MiFi设备。 部分安卓手机的热点（某些品牌型号允许关闭客户端隔离）。 虽然在车内使用iPhone热点是最便捷的方式，但看来为了实现更高级的车载办公体验，我可能需要考虑一个支持更多网络自定义功能的便携式Wi-Fi设备了。 希望这次的探索过程和结论能给有类似需求的朋友们提供一些参考，避免走弯路！如果你有更好的解决方案或经验，也欢迎分享交流。","link":"/p/250511091834/"},{"title":"简单生活准则","text":"两年前，我发现了一个能让自己瞬间变幸福的方法：扔东西。 不是在开玩笑，这里的「东西」是泛指：删掉所有非必须的 App、扔掉不会再看的书、清除那些已经想不起来是谁的联系人…… 这些事儿都能让你感觉到清空内存般畅快，绝对超过你想象的程度。 我以前不舍得扔东西，常觉得「这个没准儿以后还用得着呢」，或是「这个当时买的时候挺贵的，还是留着吧」，结果攒了一堆没用的东西，不但占了物理上的空间，而重要的是在我的「心理内存」中占据了大量空间（这个词是我杜撰的，但你应该懂我的意思），直到把它们都清空后，我才意识到当初浪费有多么巨大。 此后的几年，在总体生活成本没有提高的情况下，我的幸福感比以前高了好几倍，于是我开始以此为基点，发展我自己的「极简生活准则」，这个轻单就是我总结的要点，如果喜欢，你也可以试试。","link":"/p/1243066710/"},{"title":"目前国内比较好的TTS(语音合成)接口","text":"想在播客里加一个小功能：每天自动播报几条科技新闻。新闻来源可以通过一些接口抓取再筛选，但用真人来读成本实在太高，TTS（语音合成）如果可行，当然是比较完美的方案。大概5年前试过科大讯飞的TTS接口，当时感觉效果还不错，但用于正式的内容类产品中仍略显牵强。 5年过去了，国内的TTS水平会不会已经突飞猛进？有点期待，于是简单测试了一下，总体感受没有期待中那么大进步，用于阅读新闻等场景仍然不太理想，目前比较适合的可能还是读验证码、简短的语音提示等场景。 分别说说试过的几个接口，由于我的需求是在服务器端生成语音文件，所以测试的都是在线调用的Web接口，不是App里的SDK： 科大讯飞网址： 讯飞开放平台-在线语音合成 合成多音字、静音停顿、数字读法 优点： 精品发音人的效果比较好，其中“讯飞晓峰”比较适合播报严肃新闻 对多音字、静音停顿、数字、英文读法等提供了控制标记，比如： 着[=zhuo2]手：多音字“着”在这里读为zhuó 你好[p500]科大讯飞：静音停顿500毫秒 [n2]123[n1]456[n0]：123将会按照数值处理，读成“一百二十三”，456则会按照号码处理，读成“四五六”，其后出现的数字，则会自动判断读法 缺点： 接口有每日调用次数限制，默认500次，可申请调至2万次/天，听起来不少，可实际调用时每次不能请求太长的文本，需要拆分，如果需要生成的内容比较多，还是有可能达到上限 免费的普通发音人效果非常差，在新闻阅读的场景中，几乎不可用 精品发音人效果虽然较好，但需要付费使用，年付2万-10万元，对于免费项目来说，这个使用成本比较难接受 腾讯腾讯有好几个团队在提供相关接口，我找到的有三个： 腾讯AI实验室 腾讯优图 腾讯云 其中前两个接口都是在“腾讯AI开放平台”上提供的，可以在这里体验一下生成语音的效果，具体的文档在这里。 腾讯AI实验室接口效果不好，和科大讯飞的普通发音人差不多。 腾讯优图的效果明显好很多，目前又免费试用，且不限制请求次数，本来已经觉得可以选择了，但有一个很难接受的Bug是：无法控制英文的读法。比如对“IT”来说，有时我们希望按照单词的方式，读成“it”，但很多时候，需要按照字母的方式读出“I-T”，如果用科大讯飞的接口，可以用标记来指定想要的读法，但优图并没有提供类似的方式来指定读法，也无法足够智能的判断应该怎么读，不论传给它“it”、“It”，还是“IT”，永远都只会按照单词的方式来读，因此也无法使用。 最后试用的是腾讯云的语音合成API，文档在这里，Python的SDK在这里。 总结测试后发现，综合来说，腾讯云的语音合成接口是目前最适合我的： 优点： 生成效果非常好，个人感受甚至超过科大讯飞需要付费的精品发音人 目前内测阶段免费使用，且无调用次数限制 前面提到优图做不好的英文读法问题，腾讯云可以部分解决：传“it”会按单词读，传“IT”会按字母读 缺点： 无法控制多音字读法、数字读法、英文读法 无法控制停顿（但可以通过切分成多段文本来自己控制） 最终开发此功能时，我会选择使用腾讯云的TTS（语音合成）接口。","link":"/p/2737981892/"},{"title":"浮光掠影走美国","text":"因故出行美国一周，旧金山进纽约出，时间太紧张，无暇深度感受，只能草草记下一些浅显的印象。 从北京出发，去程选择了美联航直飞旧金山，对美国航空公司的服务早有耳闻，但心中尚存一丝侥幸，觉得未必真有那么不堪。但登机之后，心彻底凉了，美联航的服务给我的整体感受，是一种破罐子破摔的状态。 令人心生敬意的机龄首先是飞机旧，我们这架已经16年机龄，机舱里随处可见岁月的痕迹。事实证明，老而弥坚是不存在的，这架飞机没有辜负它的年龄，在连续宣布两次推迟起飞之后，终于正式确定此次航班被取消了，原因没有公布，但据听到机组内部讨论的乘客说，可能是检查时发现引擎有问题。 Shit！我的第一天行程全部被打乱，约好的人要重新约、酒店恰好定的是不可改期不可退款的…… 更讨厌的是，本来就紧张的时间，又强行被砍掉一天。 无比烦躁中下机前往航空公司安排的酒店，却发现旁边几个转机的东南亚妹子欢天喜地，对她们这种什么都比时间更贵重的年龄来说，平白多了一晚在北京玩，又有人免费承担五星级酒店和两顿饭，遇到航班取消简直像中了彩票一样幸运。 第二天重新登机，查了航班管家，欣慰的发现换了一架飞机，但高兴不过两秒，就看到这架的机龄是 22 年…… 这公司真的没有更年轻的飞机了么？！ 好在这次没有再出什么幺蛾子，至于又被推迟起飞近一个小时这种小事，几乎都没人为此感到不爽。 和空服人员的年龄比起来，飞机的年龄就显得很小了。 我说「空服」而不说「空姐」，是因为她们如果站在国内那些航空公司的空姐面前，是必须被称为「阿姨」甚至「奶奶」的。当然，我知道在长途的国际航线中，欧美航空公司多半配备中老年为主的服务团队（详情可参阅这个知乎问题），但十几个小时的漫长飞行，总还是要赏心悦目些才更好。 更何况年龄大未必意味着服务更好，我遇到的这几个大龄空姐和空爷，服务就很是牵强，首先服装都不统一，只有最外面的蓝马甲是制服，裤子和里面的衬衫则是各穿各的，格子条纹浅色深色，什么都有，一眼看去很难分清谁是空服谁是乘客。 其次服务方式、和乘客的交流方式也各不相同，每个人都有自己的风格，唯一相似的地方是同样死气沉沉，以及满脸的不耐烦，让乘客深刻的体会到他们也和我们一样在忍受长途飞行的煎熬。只有一个大概50多岁的空乘大爷比较开朗，常给两位年轻漂亮的中国女乘客额外拿些吃的，还愿意克服疲惫和她们谈笑风生。 上上下下的旧金山熬过了一夜，顺利飞到旧金山，不巧那天多云，飞机在云层之上还是晴空万里，落到地面时就灰蒙蒙的，完全看不到我心目中明媚的加州阳光。 （未完……）","link":"/p/1487346013/"},{"title":"腾讯云函数 SCF 添加 BeautifulSoup 和 lxml 依赖层：避坑与成功实践","text":"在开发腾讯云函数（SCF）时，如果需要使用像 BeautifulSoup 和 lxml 这样包含 C 扩展的 Python 库，通过“层（Layer）”来管理这些依赖是一个常见的做法。然而，这个过程并非一帆风顺，常常会遇到 ModuleNotFoundError 或者更隐蔽的运行时错误。本文将总结一次成功解决在 SCF Python 3.9 (x86_64 架构) 环境中添加 BeautifulSoup4 和 lxml 依赖层的完整过程，重点突出最终的正确操作代码和需要规避的常见陷阱。 核心痛点：为什么会出错？ 层内目录结构不正确：SCF 对层内 Python 依赖的目录结构有特定要求，如果打包错误，Python 解释器将无法找到模块。最开始我们尝试了“直接内容打包”（ZIP 包根目录是库文件），这使得 bs4 可被导入，但 lxml 仍然有问题。后来发现，尽管官方文档对目录结构的描述似乎允许直接打包，但对于复杂的 C 扩展库，遵循更标准的打包方式可能更稳妥，尽管最终成功的方案是“直接内容打包”配合正确的编译环境。 C 扩展库的二进制兼容性问题：像 lxml 这样的库依赖底层 C 库（如 libxml2, libxslt）。如果在与 SCF 运行环境不兼容的系统（例如本地 macOS/Windows，或者 GLIBC 版本不匹配的 Linux）上编译或打包这些库，会导致在 SCF 上运行时加载失败。 GLIBC 版本不匹配：这是最隐蔽也最常见的问题。通过 pip 安装的 manylinux wheel 文件对 GLIBC 版本有最低要求。如果 SCF 运行时的 GLIBC 版本低于 wheel 文件编译时所依赖的版本（例如，wheel 要求 GLIBC 2.28，而 SCF 环境只有 GLIBC 2.17 或类似版本），就会在尝试加载 .so 文件时报错（例如 version GLIBC_2.28&apos; not found）。 CPU 架构不匹配：如果在 ARM64 架构（如 Apple Silicon Mac）的 Docker 环境中为 x86_64 架构的 SCF 函数构建层，会导致架构不兼容。反之亦然。 最终成功的正确操作方式经过多次尝试，最终成功的方法结合了 Docker 构建（确保二进制兼容性、正确的 CPU 架构和正确的 GLIBC 版本）和特定的层打包方式（“直接内容打包”）。 前提条件 本地安装并运行 Docker Desktop。 目标 SCF 函数运行环境为 Python 3.9，CPU 架构为 x86_64 (非常重要！)。 步骤 1：在本地使用 Docker (强制 x86_64 平台) 构建依赖这一步的目标是在一个与 SCF x86_64 运行时 GLIBC 版本兼容的环境中安装 beautifulsoup4 和 lxml。 123456789101112131415161718192021222324252627282930# 1. 在本地电脑上创建工作目录mkdir scf_layer_lxml_final_x86cd scf_layer_lxml_final_x86# 2. 创建一个临时目录 libs 用于存放 pip install -t 的输出mkdir libs# 3. 运行 Docker 命令安装依赖到本地的 libs 目录# --platform linux/amd64 强制使用 x86_64 架构的镜像# public.ecr.aws/lambda/python:3.9 镜像是为 AWS Lambda Python 3.9 (x86_64, GLIBC 2.26) 设计的，与 SCF 兼容性好# --entrypoint \\&quot;/bin/bash\\&quot; 覆盖镜像默认入口点，以便执行自定义命令# pip install ... -t /var/installdir 将库安装到挂载的本地 libs 目录docker run --rm \\\\ --platform linux/amd64 \\\\ -v \\&quot;$(pwd)/libs\\&quot;:/var/installdir \\\\ --entrypoint \\&quot;/bin/bash\\&quot; \\\\ public.ecr.aws/lambda/python:3.9 \\\\ -c \\&quot;\\\\ echo &apos;Running pip install inside container (platform: linux/amd64) into /var/installdir...&apos;; \\\\ pip install --no-cache-dir beautifulsoup4 lxml -t /var/installdir; \\\\ echo &apos;Pip install finished. Listing contents of /var/installdir:&apos;; \\\\ ls -lR /var/installdir; \\\\ echo &apos;Attempting to chown files (may not be needed on Docker Desktop)...&apos;; \\\\ chown -R $(id -u):$(id -g) /var/installdir/* || echo &apos;Chown might have failed or was not needed.&apos;; \\\\ echo &apos;Docker script finished.&apos;\\&quot;# 4. 检查本地 libs 目录的内容# 确保 bs4 和 lxml (包含 *.cpython-39-x86_64-linux-gnu.so 文件) 都在里面ls libsls libs/lxml 关键点解释： --platform linux/amd64: 确保即使在 ARM 架构的宿主机上（如 Apple Silicon Mac），Docker 也会拉取并运行 x86_64 (amd64) 版本的镜像和 Python 包。 public.ecr.aws/lambda/python:3.9: 这个镜像的 GLIBC 版本（通常是 2.26）兼容性较好，使得 pip 在这个环境中会选择或编译出 GLIBC 依赖更低的 lxml wheel (例如 manylinux_2_17_x86_64 或 manylinux2014_x86_64)，从而避免了 GLIBC 版本过高的问题。 pip install ... -t /var/installdir: 将库安装到挂载的本地 libs 目录。 --entrypoint \\&quot;/bin/bash\\&quot; 和 -c \\&quot;...\\&quot;: 用于在 Docker 容器内正确执行 pip install 命令。 步骤 2：打包层 ZIP 文件（直接内容打包）根据最终成功的实践，我们将 libs 目录下的内容直接打包到 ZIP 文件的根目录。 1234567891011# 1. 进入 libs 目录 (在 scf_layer_lxml_final_x86 目录下)cd libs# 2. 将当前目录 (libs) 下的所有内容打包到上一级目录的 ZIP 文件中# ZIP 包的根目录将直接是 bs4/, lxml/ 等库文件夹zip -r ../scf_bs4_lxml_py39_x86_direct_content_layer.zip .# 3. 返回上一级目录cd ..# 现在 scf_bs4_lxml_py39_x86_direct_content_layer.zip 文件就在 scf_layer_lxml_final_x86 目录下了 步骤 3：上传和配置 SCF 层 登录腾讯云 SCF 控制台。 进入“层与扩展” -&gt; “层”管理页面。 点击“新建”层。 层名称：自定义，例如 BeautifulSoup4-LXML-Py39-DockerX86-Direct。 提交方法：选择“本地上传ZIP包”，上传 scf_bs4_lxml_py39_x86_direct_content_layer.zip。 兼容运行时：务必只勾选 Python 3.9 (或你函数实际使用的 Python 版本)。 创建层。 容易出错的点总结 层内目录结构混乱：最初我们尝试了将依赖放在 ZIP 包根目录下的 python/ 目录中，但对于当前 SCF 环境和用户的实践，最终是“直接内容打包”（ZIP 根目录即为库文件）配合正确的编译环境才成功。这提示我们，虽然 python/ 结构是很多平台的标准，但具体平台的行为和文档可能存在差异或演进，实践验证非常重要。 GLIBC 版本不兼容：这是导致 lxml 的 C 扩展无法加载的核心原因。直接在 Cloud Shell 中 pip install lxml 下载的 manylinux wheel (如 manylinux_2_28_x86_64) 可能对 GLIBC 版本要求过高。必须使用 GLIBC 版本要求更低的 wheel (如 manylinux_2_17_x86_64 或 manylinux2014_x86_64)，这通常需要通过在特定 Docker 环境（如 public.ecr.aws/lambda/python:3.9）中构建来实现。 CPU 架构不匹配：如果在 ARM64 宿主机上使用 Docker 构建层，而 SCF 函数是 x86_64 架构，需要使用 --platform linux/amd64 参数强制 Docker 使用 x86_64 镜像进行构建，否则会导致架构不兼容。 Docker ENTRYPOINT 问题：某些 Docker 镜像（如 AWS Lambda 官方镜像）有预设的 ENTRYPOINT，直接在 docker run 命令后附加自定义命令可能无法执行。需要使用 --entrypoint \\&quot;/bin/bash\\&quot; -c \\&quot;your_commands\\&quot; 的方式来覆盖默认入口点并执行自定义脚本。 层与函数运行环境不匹配：创建层时，必须为其“兼容运行时”选择与函数完全一致的 Python 版本和架构。 函数代码中 import 语句被注释或解析逻辑被跳过：在调试过程中，确保实际使用了层中的库，而不是因为代码中的调试语句或注释导致跳过了关键的解析步骤。 结论为 SCF Python 函数添加包含 C 扩展的依赖层（如 lxml）确实比纯 Python 库要复杂。成功的关键在于确保依赖的二进制兼容性（CPU 架构、GLIBC 版本）和正确的层打包结构。通过使用 Docker 精确控制构建环境，并结合对 SCF 平台行为的实践验证，最终可以稳定地部署和使用这些强大的库。遇到问题时，详细的日志分析和逐步排除法是解决问题的最有效途径。 希望这篇总结能帮助其他遇到类似问题的开发者！ 附：py39_bs4_lxml_docker_direct_x86_64_final.zip","link":"/p/250511195934/"}],"tags":[{"name":"知识库管理","slug":"知识库管理","link":"/tags/%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AE%A1%E7%90%86/"},{"name":"Dify实践","slug":"Dify实践","link":"/tags/Dify%E5%AE%9E%E8%B7%B5/"},{"name":"AI应用开发","slug":"AI应用开发","link":"/tags/AI%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"AI Studio","slug":"AI-Studio","link":"/tags/AI-Studio/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"Proxy","slug":"Proxy","link":"/tags/Proxy/"},{"name":"网络配置","slug":"网络配置","link":"/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"name":"代理规则","slug":"代理规则","link":"/tags/%E4%BB%A3%E7%90%86%E8%A7%84%E5%88%99/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Twitter Cards","slug":"Twitter-Cards","link":"/tags/Twitter-Cards/"},{"name":"Meta Tags","slug":"Meta-Tags","link":"/tags/Meta-Tags/"},{"name":"Twitter","slug":"Twitter","link":"/tags/Twitter/"},{"name":"Frontend","slug":"Frontend","link":"/tags/Frontend/"},{"name":"URL Preview","slug":"URL-Preview","link":"/tags/URL-Preview/"},{"name":"Cloudflare","slug":"Cloudflare","link":"/tags/Cloudflare/"},{"name":"Serverless","slug":"Serverless","link":"/tags/Serverless/"},{"name":"Workers","slug":"Workers","link":"/tags/Workers/"},{"name":"MacBook","slug":"MacBook","link":"/tags/MacBook/"},{"name":"特斯拉","slug":"特斯拉","link":"/tags/%E7%89%B9%E6%96%AF%E6%8B%89/"},{"name":"投屏","slug":"投屏","link":"/tags/%E6%8A%95%E5%B1%8F/"},{"name":"车载办公","slug":"车载办公","link":"/tags/%E8%BD%A6%E8%BD%BD%E5%8A%9E%E5%85%AC/"},{"name":"生产力","slug":"生产力","link":"/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"iPhone热点","slug":"iPhone热点","link":"/tags/iPhone%E7%83%AD%E7%82%B9/"},{"name":"客户端隔离","slug":"客户端隔离","link":"/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9A%94%E7%A6%BB/"},{"name":"tts","slug":"tts","link":"/tags/tts/"},{"name":"语音识别","slug":"语音识别","link":"/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"},{"name":"语音识别接口","slug":"语音识别接口","link":"/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E6%8E%A5%E5%8F%A3/"},{"name":"科大讯飞","slug":"科大讯飞","link":"/tags/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E/"},{"name":"腾讯优图","slug":"腾讯优图","link":"/tags/%E8%85%BE%E8%AE%AF%E4%BC%98%E5%9B%BE/"},{"name":"腾讯云","slug":"腾讯云","link":"/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"腾讯AI实验室","slug":"腾讯AI实验室","link":"/tags/%E8%85%BE%E8%AE%AFAI%E5%AE%9E%E9%AA%8C%E5%AE%A4/"},{"name":"旅行","slug":"旅行","link":"/tags/%E6%97%85%E8%A1%8C/"},{"name":"云函数","slug":"云函数","link":"/tags/%E4%BA%91%E5%87%BD%E6%95%B0/"},{"name":"SCF","slug":"SCF","link":"/tags/SCF/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"BeautifulSoup","slug":"BeautifulSoup","link":"/tags/BeautifulSoup/"},{"name":"lxml","slug":"lxml","link":"/tags/lxml/"},{"name":"层","slug":"层","link":"/tags/%E5%B1%82/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"依赖管理","slug":"依赖管理","link":"/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"}],"categories":[]}